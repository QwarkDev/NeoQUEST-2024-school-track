<h1>the_corridors_of_the_castle</h1>

<h2>Задание:</h2>
<p>Из странных писем складывается различимое послание. Кажется, я могу прочитать.</p>
<p>«Странник! Пишет тебе князь Ксеритха. Много лет назад, на охоте, я подстрелил черную птицу. Она оказалась подручной ведьмы, и та прокляла город. С тех пор мы не можем разговаривать, не способны покинуть Ксеритх и живем во тьме.  Многие пытались спасти меня – приглашенные маги, инженеры, рыцари. Но ведьма сказала, что лишь тот, кто придет из другого мира, сможет снять проклятие.  Если справишься, сделаю для тебя что угодно. Чтобы начать, найди придворного мага. Он подскажет путь».</p>
<p>Не могу поверить. Что еще за Ксеритх? Посмотреть бы в поисковике, но мой телефон не работает. Странный сбой. Серый экран, дата и время: 17 февраля 2024 года 14:12. И больше ничего. Осматриваю себя. Я как-то изменился… Меч, высокие сапоги, перчатки.  Ладно… Допустим… Я – и спасение целого города? Вот к такому повороту событий привыкнуть сложнее. Я, может быть, и не хочу никого спасать. Я этот Ксеритх впервые вижу! Сдался он мне.</p>
<p>Как до этого мага дойти-то вообще? У меня даже карты нет.</p>

<h2>Описание:</h2>
<p>В данном задании участникам необходимо восстановить исходный код из исполняемого файла и на его основе написать код, который расшифровал бы сообщение.</p>
<p>Исходный код приложения написан на языке python, поэтому для его восстановления участникам требуется сначала получить доступ к байт коду приложения (easy_chipher.pyc), а затем уже его восстановить до читаемого файла на языке python.</p>

<b>Шаг 1:</b> <span>Чтобы получить .pyc файл, можно использовать утилиту Pyinstaller Extractor или ее онлайн аналог. Для получения файла с исходным кодом .py можно использовать утилиты decompyle3 или uncompyle6.<br>После восстановления файла с исходным кодом сразу становится ясно, что байтовая строка зашифрованного сообщения это <code>b'\r\xc2\xa9\xc3\xae\xc3\x97\xc2\x85~t\xc2\x9d\xc2\xb9\xc3\x95\xc3\x93/u\xc3\x8f\xc2\xb9\xc3\x9f\xc2\x84xt\xc2\x9a\xc2\xb9\xc3\x97\xc3\x93+\'\xc3\x8f\xc2\xbe\xc3\x92\xc2\x8f+%\xc2\x9a\xc3\xad\xc3\x9f\xc2\x80ru\xc3\x8b\xc2\xb9\xc2\x83\xc2\x80,w\xc2\x9d\xc3\xaa\xc3\x95\xc3\x96,{\xc3\x8d\xc3\xaf\xc3\x9f\xc2\x87}!\xc3\x88\xc2\xb9\xc2\x84\xc3\x93{%\xc3\x8a\xc3\xaf\xc2\x84\xc3\x96r"\xc3\x81\xc3\xac\xc3\x9e'</code></span><br>


<b>Шаг 2:</b> <span>Исходная строка шифруется в функции encoding(), которая кроме всего прочего в качестве аргумента получает ключ, который представляет собой 6 случайно сгенерированных чисел. Именно для восстановления ключа, с помощью которого была зашифрована первоначальная строка, в задании указано, в какое время было зашифровано сообщение. Участнику необходимо перевести время 17.02.2024, 14.12 в Unix формат, так как именно это возвращает функция time(), а затем передавать это значение в качестве аргумента вместо time.time(). Таким образом будет сгенерирован нужный ключ и функция getkey() будет выглядеть так:</span>

<pre lang="python">
<code>
def getkey():
    random.seed(1708179178)
    key = []
    for i in range(0, 6):
        temp = random.randint(0, 256)
        key.append(temp)
    return key
</code>
</pre>

<b>Шаг 3:</b> <span>Так как в задании дано время без секунд, а для получения точного значения Unix времени они нужны, нужно будет перебрать всего 60 значений от 1708179120 (14:12:00) до 1708179179 (14:12:59). Точное время для решения: 1708179178 (14:12:58).</span>

<p>Сам алгоритм заключается в обработке блоков длиной 6 символов, при этом к каждому символу в блоке применяется операция исключающего или XOR с соответствующим числом в ключе. Т.к. операция XOR обратима, то для декодирования с нужным ключом можно использовать ту же функцию encoding(), только при условии подачи байтовой строки в эту функцию использовать метод decode():</p>

<pre lang="python">
<code>
import random
import time

def encoding(string, key):
    str_encode = ""
    for i in range(0, len(string), 6):
        block = string[i:i+6]
        encode_block = ""
        for j in range(len(block)):
            temp = ord(block[j]) ^ key[j]
            encode_block += chr(temp)
        str_encode += encode_block
    return str_encode.encode()

def getkey():
    random.seed(int(time.time()))
    key = []
    for i in range(0, 6):
        temp = random.randint(0, 256)
        key.append(temp)
    return key

print("[*] Hey guys! This is cipher program")
print("[*] Write the message:")
message = str(input())
  
if message.encode() == b'\r\xc2\xa9\xc3\xae\xc3\x97\xc2\x85~r\xc3\x8b\xc3\xa4\xc3\x96\xc2\x8f}z\xc3\x8e\xc3\xa9\xc3\x90\xc2\x83rw\xc3\x81\xc3\xad\xc3\x97\xc2\x86}r\xc3\x8d\xc3\xad\xc3\x97\xc2\x8exu\xc3\x8a\xc3\xab\xc3\x97\xc2\x82{s\xc3\x81\xc3\xa8\xc3\x95\xc2\x86rs\xc3\x81':
    print("[ERORR] You want to hack me!? Nope.")
else:
    encode = encoding(message, getkey())
    print("[*] Encoding message: ", encode)
  
print("[*] Press enter to exit")
input()
</code>
</pre>
